<!doctype html>
<html>

<head>
	<meta charset="utf-8">
	<title>Sudoku  C# Bit81</title>
	<link href="google-code-prettify/prettify.css" rel="stylesheet" type="text/css" >
	<script src="google-code-prettify/prettify.js" type="text/javascript"> </script>
	
	<script src="lib/jquery.js" type="text/javascript"></script>
	<script src="lib/jquery.cookie.js" type="text/javascript"></script>
	<script src="js/jquery.treeview.js" type="text/javascript"></script>
	<script src="js/treeView.js" type="text/javascript" ></script>
	
	<script src="js/naviHeader.js" type="text/javascript" > </script>
	<script src="js/naviAlgorithm.js" type="text/javascript" > </script>
	
	<link rel="stylesheet" href="css/jquery.treeview.css">
	<link rel="stylesheet" href="css/screen.css">

	<link href="styleStandardEng.css" rel="stylesheet">
</head>

<body id="page" onload="prettyPrint()">

	<a id="pageTop"></a>
	<header>
		<img src="images/imgTop/SuDoKuAlgorithm3.jpg">	</header>

    <script type="text/javascript"> writeNaviHeader(); </script>
	
<!-- ========================================================================== -->
<section id="menuList">
	<aside>
		<script type="text/javascript"> writeNaviAlgorithm(); </script>	
	</aside>
</section>

<!-- ======================================================================== -->		
<section id="main">
	<article>
		<h2>Bit81</h2>
		<p>This class represents Sudoku state. 81 cells are represented by 81 
		bits.The element is an identifier(ID) and an integer array of size 
		3(_BP).It is rare to directly access these elements, but they are 
		handled via various functions.The elements and functions of class &quot;Bit81&quot; are shown below </p>
		<pre class="prettyprint linenums lang-C "><small> public class Bit81{
    public int   ID;
    public readonly int[] _BP;

    public int Count{ get{ return BitCount(); } }

    public Bit81( ){ _BP=new int[3]; }
    public Bit81( int rc ):this(){ BPSet(rc); }
    public Bit81( Bit81 P ):this(){
        this._BP[0]=P._BP[0]; this._BP[1]=P._BP[1]; this._BP[2]=P._BP[2]; 
    }
    public Bit81( List&lt;UCell&gt; X ):this(){
        X.ForEach(P=&gt;{ _BP[P.rc/27] |= (1&lt;&lt;(P.rc%27)); } );
    }
    public Bit81( List&lt;UCell&gt; X, int F, int FreeBC=-1　):this(){
        if( FreeBC&lt;0 ) X.ForEach(P=&gt;{ if( (P.FreeB&F)&gt;0 ) _BP[P.rc/27] |= (1&lt;&lt;(P.rc%27)); } );
        else X.ForEach(P=&gt;{ if( (P.FreeB&F)&gt;0 && P.FreeBC==FreeBC ) _BP[P.rc/27] |= (1&lt;&lt;(P.rc%27)); } );
    }
    public Bit81( List&lt;UCell&gt; X, int noB ):this(){
        X.ForEach(P=&gt;{ if( (P.FreeB&noB)&gt;0 ) _BP[P.rc/27] |= (1&lt;&lt;(P.rc%27)); } );
    }

    public void Clear( ){ _BP[0]=_BP[1]=_BP[2]=0; }
    public void BPSet( int rc ){ _BP[rc/27] |= (1&lt;&lt;(rc%27)); }
    public void BPSet( Bit81 sdX ){ for( int nx=0; nx&lt;3; nx++ ) _BP[nx] |= sdX._BP[nx]; }               
    public void BPReset( int rc ){ _BP[rc/27] &= ((1&lt;&lt;(rc%27))^0x7FFFFFF); }

    public int  AggregateFreeB( List&lt;UCell&gt; XLst ){
        return this.IEGet_rc().Aggregate(0,(Q,q)=&gt;Q|XLst[q].FreeB);
    }
    public Bit81 Copy(){ Bit81 Scpy = new Bit81(); Scpy.BPSet(this); return Scpy; }

    static public Bit81 operator|( Bit81 sdA, Bit81 sdB ){
        Bit81 sdC = new Bit81();
        for( int nx=0; nx&lt;3; nx++ ) sdC._BP[nx] = sdA._BP[nx] | sdB._BP[nx];
        return sdC;
    }
    static public Bit81 operator&( Bit81 sdA, Bit81 sdB ){
        Bit81 sdC = new Bit81();
        for( int nx=0; nx&lt;3; nx++ ) sdC._BP[nx] = sdA._BP[nx]&sdB._BP[nx];
        return sdC;
    }
    static public Bit81 operator^( Bit81 sdA, Bit81 sdB ){
        Bit81 sdC = new Bit81();
        for( int nx=0; nx&lt;3; nx++ ) sdC._BP[nx] = sdA._BP[nx] ^ sdB._BP[nx];
        return sdC;
    }
    static public Bit81 operator^( Bit81 sdA, int sdbInt ){
        Bit81 sdC = new Bit81();
        for( int nx=0; nx&lt;3; nx++ ) sdC._BP[nx] = sdA._BP[nx] ^ sdbInt;
        return sdC;
    }
    static public Bit81 operator-( Bit81 sdA, Bit81 sdB ){
        Bit81 sdC = new Bit81();
        for( int nx=0; nx&lt;3; nx++ ) sdC._BP[nx] = sdA._BP[nx] & (sdB._BP[nx]^0x7FFFFFF);
        return sdC;
    }

    static public bool operator==( Bit81 sdA, Bit81 sdB ){
        try{
            for( int nx=0; nx&lt;3; nx++ ){ if( sdA._BP[nx]!=sdB._BP[nx] ) return false; }
            return true;
        }
        catch( NullReferenceException ){ return true; }
    }
    static public bool operator!=( Bit81 sdA, Bit81 sdB ){
        try{
            for( int nx=0; nx&lt;3; nx++ ){ if( sdA._BP[nx]!=sdB._BP[nx] ) return true; }
            return false;
        }
        catch( NullReferenceException ){ return false; }
    }

    public override int GetHashCode(){ return ( _BP[0]^ (_BP[1]*1301)^ (_BP[2]*6577) ); }
    public int CompareTo( Bit81 sdB ){
        if( this._BP[0]==sdB._BP[0] )  return (this._BP[0]-sdB._BP[0]);
        if( this._BP[1]==sdB._BP[1] )  return (this._BP[1]-sdB._BP[1]);
        return (this._BP[2]-sdB._BP[2]);
    }

    public bool IsHit( int rc ){ return ((_BP[rc/27]&(1&lt;&lt;(rc%27)))&gt;0); }
    public bool IsHit( Bit81 sdk ){
        for( int nx=0; nx&lt;3; nx++ ){
            if( (_BP[nx]&sdk._BP[nx])&gt;0 )  return true;
        }
        return false;
    }
    public bool IsHit( List&lt;UCell&gt; LstP ){ return LstP.Any(P=&gt;(IsHit(P.rc))); }

    public bool IsZero( ){
        for( int nx=0; nx&lt;3; nx++ ){
            if( _BP[nx]&gt;0 )  return false;
        }
        return true;
    }    
    public override bool Equals( object obj ){
        Bit81 A = obj as Bit81;
        for( int nx=0; nx&lt;3; nx++ ){ if( A._BP[nx]!=_BP[nx] ) return false; }
        return true;
    }       
    public int  BitCount( ){
        int bc = _BP[0].BitCount() + _BP[1].BitCount() + _BP[2].BitCount();
        return bc;
    } 
    
    public int FindFirstrc(){
        for( int rc=0; rc&lt;81; rc++ ){
            if( this.IsHit(rc) ) return rc;
        }
        return -1;
    }
    public List&lt;int&gt; ToList(){
        List&lt;int&gt; rcList = new List&lt;int&gt;();
        for( int n=0; n&lt;3; n++ ){
            int bp = _BP[n];
            for( int k=0; k&lt;27; k++){
                if( (bp&(1&lt;&lt;k)) &gt; 0 ) rcList.Add(n*27+k);
            }
        }
        return rcList;
    }

    public void CompressRow3( out int r9c3, out int c9r3 ){
        int r, c, b;
        r9c3=0;
        c9r3=0;

        for( int n=0; n&lt;3; n++ ){
            int bp = _BP[n];
            for( int k=0; k&lt;27; k++){
                if( ((bp&gt;&gt;k)&1)==0 )  continue;
                r = k/9 + n*3;
                c = k%9;
                b = (r/3*3+c/3);
                r9c3 |= 1&lt;&lt;(b*3+c%3);
                c9r3 |= 1&lt;&lt;(b*3+r%3);
            }
        }
    }
    public override string ToString(){
        string st=&quot;&quot;;
        for( int n=0; n&lt;3; n++ ){
            int bp =_BP[n];
            int tmp=1;
            for( int k=0; k&lt;27; k++){
                st += ((bp&tmp)&gt;0)? ((k%9)+0).ToString(): &quot;.&quot;; //internal representation
            //  st += ((bp&tmp)&gt;0)? ((k%9)+1).ToString(): &quot;.&quot;; //External representation
                tmp = (tmp&lt;&lt;1);
                if( k==26 )         st += &quot;#&quot;;
                else if( (k%9)==8 ) st += &quot; &quot;;
            }
        }
        return st;
    }
    public string ToRCString(){
        string st=&quot;&quot;;
        for( int n=0; n&lt;3; n++ ){
            int bp=_BP[n];
            for( int k=0; k&lt;27; k++){
                if( (bp&(1&lt;&lt;k))==0 )  continue;
                int rc = n*27+k;
                st += &quot; [&quot;+(rc/9*10+rc%9+11)+&quot;]&quot;;
            }
        }
        return st;
    }
}</small></pre>
   		<p>
  		This class makes a big success with the following analysis algorithm. 
		For example, "The bit representation of a cell containing the candidate 
		number #N(internal representation) in the board" can be obtained by the 
		code of the next line.</p>		
  		<p>Bit81 A= new Bit81(pBDL,(1&lt;&lt;N))；</p>
  		
   		<p>
  		i have previously determined the cell position ConnectedCells[rc] where 
		cells in cell[rc] and rows/columns/blocks are related (this is a 
		priori determined).<br>Here, if cell[rc] is decided as the number #N
		i can exclude #N from the candidate number of the cell at the 
		position where the bit is set.</p>
		<p>A & ConnectedCells[rc]；</p>
		
		<p>
  		By bit representation, these operations can be executed without repetition calculation. 
  		Of course, although iterative calculations are performed inside the function of Bit81.
  		The common part of the &amp; operation can be found without being conscious of it.
  		This is an abstraction using classes,
  		there are also realistic advantages that program bugs are hard to occur.
  		</p>
  		
  	  	<p>
  	  	ToString (override function) is a function for development and debugging purposes. For example, use as follows.<br><br>
  	  	
  	  	Bit 81 X = new Bit81(0*9+1) | new Bit81(2*9+4) | new Bit81(5*9+7))<br>
  	  	Console.WriteLine (X);</p>
  	  
  	  	<p>The output is as follows. Functions for development and debugging are equivalent to tools and measuring instruments,
  	  	so if you do not spare trouble, you can improve development efficiency.</p>
   		<p>
		.1....... ......... ....4....#......... ......... .......7.#......... ......... .........#
   		</>
	
<!-- ======================================================================== -->				
		
	</article>
</section>
	
<footer>
	<p id="copyright">Copyright &copy; 2014- GNPX. All rights reserved.</p>
</footer>

</body>

</html>
